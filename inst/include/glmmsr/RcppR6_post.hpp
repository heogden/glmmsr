// Generated by RcppR6 (0.2.4): do not edit by hand
#ifndef _GLMMSR_RCPPR6_POST_HPP_
#define _GLMMSR_RCPPR6_POST_HPP_

#include <Rcpp.h>
#include <glmmsr/RcppR6_support.hpp>

namespace glmmsr {
namespace RcppR6 {
namespace traits {
template <> inline std::string   class_name_r<std::vector<MixedContinuousBelief> >() {return "continuous_beliefs";}
template <> inline std::string   package_name<std::vector<MixedContinuousBelief> >() {return "glmmsr";}
template <> inline std::string generator_name<std::vector<MixedContinuousBelief> >() {return ".R6_continuous_beliefs";}
template <> inline std::string   class_name_r<Parameters >() {return "calibration_parameters";}
template <> inline std::string   package_name<Parameters >() {return "glmmsr";}
template <> inline std::string generator_name<Parameters >() {return ".R6_calibration_parameters";}
template <> inline std::string   class_name_r<ClusterGraph >() {return "cluster_graph";}
template <> inline std::string   package_name<ClusterGraph >() {return "glmmsr";}
template <> inline std::string generator_name<ClusterGraph >() {return ".R6_cluster_graph";}
template <> inline std::string   class_name_r<Family >() {return "extended_family";}
template <> inline std::string   package_name<Family >() {return "glmmsr";}
template <> inline std::string generator_name<Family >() {return ".R6_extended_family";}
}
}
}

namespace Rcpp {
template <typename T>
SEXP wrap(const glmmsr::RcppR6::RcppR6<T>& x) {
  return x.to_R6();
}

namespace traits {
template <typename T>
class Exporter<glmmsr::RcppR6::RcppR6<T> > {
public:
  Exporter(SEXP x) : obj(glmmsr::RcppR6::RcppR6<T>(x)) {}
  inline glmmsr::RcppR6::RcppR6<T> get() { return obj; }
private:
  glmmsr::RcppR6::RcppR6<T> obj;
};
}

template <> inline SEXP wrap(const std::vector<MixedContinuousBelief>& x) {
  return wrap(glmmsr::RcppR6::RcppR6<std::vector<MixedContinuousBelief> >(x));
}
template <> inline std::vector<MixedContinuousBelief> as(SEXP x) {
  return *(glmmsr::RcppR6::RcppR6<std::vector<MixedContinuousBelief> >(x));
}
template <> inline SEXP wrap(const Parameters& x) {
  return wrap(glmmsr::RcppR6::RcppR6<Parameters>(x));
}
template <> inline Parameters as(SEXP x) {
  return *(glmmsr::RcppR6::RcppR6<Parameters>(x));
}
template <> inline SEXP wrap(const ClusterGraph& x) {
  return wrap(glmmsr::RcppR6::RcppR6<ClusterGraph>(x));
}
template <> inline ClusterGraph as(SEXP x) {
  return *(glmmsr::RcppR6::RcppR6<ClusterGraph>(x));
}
template <> inline SEXP wrap(const Family& x) {
  return wrap(glmmsr::RcppR6::RcppR6<Family>(x));
}
template <> inline Family as(SEXP x) {
  return *(glmmsr::RcppR6::RcppR6<Family>(x));
}
}

#endif
